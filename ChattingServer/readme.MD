## ChattingServer 설계

main -> ChattingServer init 후 실행  

ChattingServer: 소켓프로그래밍 중심. Accept, Recv이후 Token으로 전달, Token이 요청한 바이트 배열 송신을 처리  

SocketToken: 연결돼있는 소켓 상태 처리.  
데이터를 받으면 MessageManager로 넘긴 후 Message 완성되면 받아서 Server의 MessageHandler로 넘김  
Handler가 토큰에 메시지 송신을 요청하면 바이트 배열로 변환 후 server에 송신 요청을 함  

MessageHandler: 서버 동작 핵심 로직 구현  
각 메시지 핸들러로 전달, DB 조작, 저장해놓은 토큰을 통해 메시지 송신 요청  


IOCP 워커 스레드:
	수신 처리
		소켓 수신 데이터 처리, 소켓 매니저로 넘긴 후 소켓 매니저가 메시지 매니저한테 파싱 요청하고서 
		메시지 있으면, 그거 받아서 메시지 큐에 넣는거까지 완료한 후 다시 해당 소켓 수신 걸어놓고 IO 대기
	송신 처리
		소켓 매니저를 통해, 메시지 매니저 - 버퍼 매니저에게 송신 메시지 버퍼 반환
		소켓 송신 블록 풀기  
		해당 소켓에 송신할 메시지 큐가 쌓여있으면, 송신 워커 쪽에 시그널 줘서 깨움, 다시 IO 대기
	연결 처리

메시지 핸들러 워커 스레드:
	메시지 큐 처리 및 메시지 생성 하고서 대상 소켓 송신 큐에 추가, 송신 스레드에 시그널.
	메시지 처리 끝나면 수신 메시지 버퍼 반환

송신 워커 스레드:
	소켓 송신 큐 처리, 얘가 처리하는 동안 해당 소켓에 대한 다른 송신 연산, 스레드 접근 블록  
	큐에서 메시지 여러개 뽑아서. 최대 1024바이트로 묶어서 보냄(보통 mtu 1500바이트라고 하길래 이게 적절하지 않을까)  
	WSA IO 함수에서 버퍼 여러개 설정하는게 있는걸로 기억하는데, 그걸로 버퍼 추가로 안 만들고 땜빵할 수 있을라나

char, unsgiend char 자료형에 따른 연산 차이(없다고 알긴 함)  

서버는 기본적으로 소켓 매니저 수(메시지 매니저 수) 만큼의 메시지 버퍼를 잡아먹음(MaxConnection = 10'000)  

접속 끊겼을 때 처리  
들고 있는 메시지 버퍼 반환 -> 메시지 매니저가 가지고 있는 메시지 비우기, Send중인 버퍼 반환.
메시지 핸들러가 메시지 소모하고서 다시 소켓 매니저를 통해 메시지 버퍼를 반환하는데, 그냥 바로 메시지 핸들러가 반환하도록 변경  
추가적인 접속 해제 처리(map에서 삭제, 채팅서버측 카운트 감소, 소켓매니저 리셋...)

메시지 핸들러측에서 소켓 매니저의 상태를 식별번호(유닉스시간)로 식별  
소켓이 연결된 시간을 저장한 후 소켓 핸들러에 자신을 등록, 소켓 핸들러는 a 유저와 연결돼있다고 생각하는 소켓매니저에 메시지를 큐잉,  
소켓매니저가 그 사이에 b 유저와의 연결로 바뀌었다면 식별번호를 가지고 메시지를 송신을 취소함.

현재 클라이언트 스레드관리 쪽에서 IsRunning 바로 꺼놓으면 뭔가 이상하게 동작하고,   
그건 차치하고서 서버측에서 클라가 꺼져도 연결이 안 끊기던데 뭔지 

PIE 여러개 켜놓으면 그거 다 같은 이름으로 로그인 됨..? 