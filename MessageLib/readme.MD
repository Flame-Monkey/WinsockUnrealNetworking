# 프로토콜
HTTP/2에서 따옴

# 메시지 매니저, 메모리 풀
메시지 종류별 크기 구분 없이 고정된 크기로 메모리 풀 할당

메시지 헤더 14 바이트

(ChattingMessage(151 bytes), FriendMessage(51 bytes) => 구분 없이 192bytes 할당)  
대용량 파일 송수신 같은 큰 메시지의 경우, 별도의 메모리 할당(슬롯당 192 * 10 = 1920 bytes)  

버퍼 매니저에 메시지는 최대 기본값 1M

메시지 매니저한테 버퍼 할당 192 바이트 씩.  
메시지매니저는, 바이트 수신 받을 때, 먼저 14바이트 저장하면서 읽고, 페이로드 길이에 따라 나머지 바이트 저장을 처리  
(그냥 저장, 일부 저장 후 새 버퍼 할당받고서 저장)  

지금 구조면, 유저메모리에서의 한 번의 복사가 일어나게 됨(소켓에 할당한 메모리 -> 메시지 매니저 메모리)  
소켓에 할당한 메모리에서 바로 데이터를 유효하게 사용하려면 해당 스트림을 바로 파싱해야하는데 그럼 구조간에 많이 종속적이게 됨  
이 때 방법 1. 헤더 만큼의 버퍼를 할당해서 읽고, 페이로드 만큼의 버퍼를 할당해서 읽고(C#프로젝트에서 한 방식)  
방법 2. 큰 메모리 버퍼에서 메시지를 연속적으로 받아서 사용하다가, 마지막에 메시지 자리가 부족하면 해당 스트림부분만 일부 복사해서 사용

일단 복사하는 방향으로 만들어놓고, 나중에 수정해보기로  

송신 버퍼, 대용량 파일 수신 버퍼 1024 바이트로 할당, 1024개 => 1MB

PayloadBase 상속시켜서, 메시지 다형성 구현하고 싶은데, 그러면 앞에 포인터 붙어서 바이트를 그대로 사용할 수가 없음.
구조체 쓰고 일일이 switch case로 매칭 시켜야 할 듯.. 아니면 struct 하나에 몰아넣고 Union 쓰든가

메시지 구조를 아에 바꿔야 하나? 데이터 유형(xml, json 같은걸 보내는걸로)
HTTP/1, /2가 어떻게 동작하는지 알면 좋을 듯

메시지 버퍼를 동적으로 늘릴 수 있을까?  
현재 메시지 버퍼를 고정된 크기(기본값 192)로 할당하는데, 그보다 큰 메시지를 받고싶으면 OS에서 페이징하는 것 처럼  
따로 여러가지 버퍼를 받아 참조하는 식으로 구현해야 됨.  
이러면 메시지로부터 데이터 참조하는 것도, 기존 struct에서 쭉 읽는 것처럼 하는게 아니라 따로 각 데이터마냥 함수 둬서 읽게 해야할거 같음.  
지금은 구현 생각 없음.

